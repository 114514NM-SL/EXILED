<h1 align="center">EXILED - EXtended In-runtime Library for External Development</h1>
<div align="center">
    
[<img src="https://img.shields.io/github/actions/workflow/status/Exiled-Team/EXILED/main.yml?style=for-the-badge&logo=githubactions&label=build" alt="CI"/>](https://github.com/Exiled-Team/EXILED/actions/workflows/main.yml/badge.svg?branch=master)
<a href="https://github.com/Exiled-Team/EXILED/releases"><img src="https://img.shields.io/github/v/release/Exiled-Team/EXILED?display_name=tag&style=for-the-badge&logo=gitbook&label=Release" href="https://github.com/Exiled-Team/EXILED/releases" alt="GitHub Releases"></a>
<img src="https://img.shields.io/github/downloads/Exiled-Team/EXILED/total?style=for-the-badge&logo=github" alt="Downloads">
![Github Commits](https://img.shields.io/github/commit-activity/w/Exiled-Team/EXILED/apis-rework?style=for-the-badge&logo=git)
<a href="https://discord.gg/PyUkWTg">
    <img src="https://img.shields.io/discord/656673194693885975?style=for-the-badge&logo=discord" alt="Chat on Discord">
</a>    

</div>

EXILED - это высокоуровневый фреймворк для разработки плагинов для серверов SCP: Secret Laboratory. Он предлагает систему событий, которую разработчики могут использовать чтобы изменять игровой код или реализовывать собственные функции.
Все события EXILED реализованы при помощи Harmony, что означает, что для их работы не требуется прямое редактирование кода игры, что позволяет получить два уникальных преимущества:

 - Во-первых, весь код фреймворка может быть свободно опубликован, что позволяет разработчикам лучше понимать, *как* он работает, и предлагать идеи для добавления или изменения его функций.
 - Во-вторых, поскольку весь код, связанный с фреймворком, выполняется вне сборки сервера, такие вещи, как небольшие обновления игры, будут иметь очень мало влияния на фреймворк. Это делает EXILED совместимым с будущими обновлениями игры, а также упрощает его обновление, когда это *необходимо*.

# Установка
Установить EXILED достаточно просто. Он загружается через Northwood PluginAPI. Поэтому в архиве ``Exiled.tar.gz`` в файлах релиза находятся две папки. Папка ``SCP Secret Laboratory`` содержит необходимые файлы для загрузки функций фреймворка из папки ``EXILED``. Все, что вам нужно сделать, это переместить эти две папки по соответствующим путям, описанным ниже, и все готово!

Если вы решите использовать установщик, он, при правильном запуске, позаботится об установке всех функций EXILED.

# Windows
### Автоматическая установка ([подробнее](https://github.com/Exiled-Team/EXILED/blob/master/Exiled.Installer/README.md))
**Примечание**: Убедитесь, что вы используете учетную запись, которая запускает сервер, или у вас есть права администратора перед запуском Установщика.

  - Загрузите **`Exiled.Installer-Win.exe` [отсюда](https://github.com/Exiled-Team/EXILED/releases)** (Assets -> `Exiled.Installer-Win.exe`)
  - Разместите установщик в папке вашего сервера (загрузите SCP-SL сервер, если у вас его еще нет)
  - Дважды щелкните **`Exiled.Installer.exe`** или **[скачайте этот .bat](https://www.dropbox.com/s/xny4xus73ze6mq9/install-prerelease.bat?dl=1)** и разместите его в папке сервера, чтобы установить последнюю предварительную версию.
  - Для скачивания и установки плагинов ознакомьтесь с разделом [Установка плагинов](#установка-плагинов) ниже.
**Примечание:** Если вы устанавливаете EXILED на удаленный сервер, убедитесь, что запускаете .exe от того же пользователя, что и ваши серверы SCP:SL (или от пользователя с правами администратора)

### Ручная установка
  - Загрузите **`Exiled.tar.gz` [отсюда](https://github.com/Exiled-Team/EXILED/releases)**
  - Извлеките его содержимое с помощью [7Zip](https://www.7-zip.org/) или [WinRar](https://www.win-rar.com/download.html?&L=6)
  - Переместите папку **``EXILED``** в **`%appdata%`** *Примечание: Эта папка должна находиться в ``C:\Users\%UserName%\AppData\Roaming``, а ***НЕ*** в ``C:\Users\%UserName%\AppData\Roaming\SCP Secret Laboratory``, и **ОБЯЗАТЕЛЬНО** должна быть в (...)\AppData\Roaming, а не просто в (...)\AppData\!*
  - Нажмите Win + R и введите `%appdata%`
  - Переместите **``SCP Secret Laboratory``** в **`%appdata%`**.

### Установка плагинов
Вот и все, EXILED теперь установлен, и должен запустится при следующей загрузке сервера. Обратите внимание, что сам по себе EXILED практически ничего не делает, поэтому вы можеье скачайть плагины с **[нашего сервера Discord](https://discord.gg/PyUkWTg)**
- Для установки плагина просто:
  - Загрузите плагин со [страницы его релиза](https://i.imgur.com/u34wgPD.jpg) (**он ОБЯЗАТЕЛЬНО должен быть `.dll`!**)
  - Переместите его в: ``C:\Users\%UserName%\AppData\Roaming\EXILED\Plugins`` (перейдите сюда, нажав Win + R, затем написав `%appdata%`)

# Linux
### Автоматическая установка ([подробнее](https://github.com/Exiled-Team/EXILED/blob/master/Exiled.Installer/README.md))

**Примечание:** Если вы устанавливаете EXILED на удаленный сервер, убедитесь, что запускаете Установщик от того же пользователя, что и ваши серверы SCP:SL (или от root)

  - Загрузите **`Exiled.Installer-Linux` [отсюда](https://github.com/Exiled-Team/EXILED/releases)** (Assets -> `Exiled.Installer-Linux`)
  - Используйте команду **`./Exiled.Installer-Linux --path /path/to/server`**, либо переместите установщик непосредственно в папку сервера
  - Перейдите к нему через терминал (`cd`), и введите: **`./Exiled.Installer-Linux`**.
  - Если вы хотите установить предварительную версию, просто добавьте **`--pre-releases`**. Пример: **`./Exiled.Installer-Linux /home/scp/server --pre-releases`**
  - Другой пример, если вы поместили `Exiled.Installer-Linux` в папку вашего сервера: **`/home/scp/server/Exiled.Installer-Linux --pre-releases`**
  - Для скачивания и установки плагинов ознакомьтесь с разделом [Установка плагинов](#установка-плагинов) ниже.

### Ручная установка
  - **Убедитесь**, что вы подключились к хосту от пользователя, который запускает сервера (или root).
  - Загрузите **`Exiled.tar.gz` [отсюда](https://github.com/Exiled-Team/EXILED/releases)** (SSH: щелкните правой кнопкой мыши и получите ссылку `Exiled.tar.gz`, затем введите: **`wget (ссылка_для_загрузки)`**)
  - Чтобы извлечь его в текущую папку, введите **``tar -xzvf EXILED.tar.gz``**
  - Переместите папку **`EXILED`** в **``~/.config``**. *Примечание: Эта папка должна находиться в ``~/.config``, и ***НЕ*** в ``~/.config/SCP Secret Laboratory``* (SSH: **`mv EXILED ~/.config/`**)
  - Переместите папку **`SCP Secret Laboratory`** в **``~/.config``**. *Примечание: Эта папка должна находиться в ``~/.config``, и ***НЕ*** в ``~/.config/SCP Secret Laboratory``* (SSH: **`mv SCP Secret Laboratory ~/.config/`**)

### Установка плагинов
Вот и все, EXILED теперь установлен, и должен запустится при следующей загрузке сервера. Обратите внимание, что сам по себе EXILED практически ничего не делает, поэтому вы можеье скачайть плагины с **[нашего сервера Discord](https://discord.gg/PyUkWTg)**
- Для установки плагина просто:
  - Загрузите плагин со [страницы его релиза](https://i.imgur.com/u34wgPD.jpg) (**он ОБЯЗАТЕЛЬНО должен быть `.dll`!**)
  - Переместите его в: ``~/.config/EXILED/Plugins`` (если вы вошли как root, тогда ищите правильный `.config`, который будет внутри `/home/(Нужный пользователь)`)

# Конфигурация
EXILED сам по себе предлагает некоторые настройки.
Все они автоматически генерируются при запуске сервера, и находятся в файле ``~/.config/EXILED/Configs/(ПортСервера)-config.yml`` (``%AppData%\EXILED\Configs\(ПортСервера)-config.yml`` на Windows).

Настройки плагинов ***НЕ*** будут находится в файле ``config_gameplay.txt``, вместо этого они задаются в файле ``~/.config/EXILED/Configs/(ПортСервера)-config.yml`` (``%AppData%\EXILED\(ПортСервера)-config.yml`` на Windows).
Однако, некоторые плагины могут самостоятельно получать свои настройки из других мест, а это просто стандартное местоположение EXILED, поэтому проверяйте отдельный плагин, если возникнут проблемы.

# Для разработчиков

Если вы хотите создать плагин для EXILED, это не сложно. Для более подробной информации обратитесь к [Getting Started Page (Eng)](https://github.com/Exiled-Team/EXILED/blob/master/GettingStarted.md).

При разработке ваших плагинов, обязательно следуйте этим правилам:

 - Ваш плагин должен содержать класс, наследующийся от ``Exiled.API.Features.Plugin<>``, в противном случае, EXILED не сможет загрузить ваш плагин при запуске сервера.
 - Когда плагин загружается, код внутри метода ``OnEnabled()`` немедленно выполняется. Он не ждет загрузки других плагинов. Он не ждет завершения процесса запуска сервера. ***Он не ждет ничего.*** При создании метода ``OnEnabled()`` убедитесь, что вы не обращаетесь к вещам, которые могут быть еще не загружены сервером, таким как ``ServerConsole.Port``, или ``PlayerManager.localPlayer``.
 - Если вам нужно получить доступ к вещам на раннем этапе, которые не инициализированы до загрузки вашего плагина, рекомендуется дождаться события ``WaitingForPlayers``, для этого оберните код в цикл ``` while(!x)```, который проверяет, чтобы переменная/объект, к которой вы хотите получить доступ, больше не была null, прежде чем продолжить.
 - EXILED поддерживает динамическую перезагрузку плагинов во время выполнения, благодаря чему, если вам нужно обновить плагин, это можно сделать без перезагрузки сервера. Однако, если вы обновляете плагин во время выполнения, плагин должен быть разработан должным образом для поддержки этого, иначе у вас будут большие проблемы. Смотрите раздел ``Динамические обновления`` для получения дополнительной информации и рекомендаций, которым следует следовать.
 - В EXILED ***НЕТ*** событий OnUpdate, OnFixedUpdate или OnLateUpdate. Если вам нужно часто выполнять код, вы можете использовать корутину MEC, которая ждет один кадр, 0.01f, или использовать слой Timing, например Timing.FixedUpdate вместо этого.
 ### Корутины MEC
Если вы не знакомы с MEC, это будет очень краткое и простое введение.
Корутины MEC - это по сути асинхронные методы, поддерживающие ожидание перед продолжением выполнения, при этом не прерывая основной игровой поток.
Корутины MEC безопасны для использования с Unity, в отличие от традиционного многопоточности. ***НЕ пытайтесь создавать новые потоки для взаимодействия с Unity, они УРОНЯТ сервер.***

Чтобы использовать MEC, вам нужно будет ссылаться на ``Assembly-CSharp-firstpass.dll`` из файлов сервера и включить ``using MEC;``.
Пример вызова простой корутины, которая повторяется с задержкой между каждым циклом:
```cs
using MEC;
using Exiled.API.Features;

public void SomeMethod()
{
    Timing.RunCoroutine(MyCoroutine());
}

public IEnumerator<float> MyCoroutine()
{
    for (;;) //повторять следующий код бесконечно
    {
        Log.Info("Привет, я бесконечный цикл!"); //Вызовите Log.Info, чтобы вывести строку в игровую консоль/журналы сервера.
        yield return Timing.WaitForSeconds(5f); //Ждет 5 секунд перед продолжением вполнения. Такой цикл будет повторятся каждые 5 секунд.
    }
}

```

***Настоятельно*** рекомендуем погуглить или спросить в Discord, если вы не знакомы с MEC и хотели бы узнать больше, получить совет или нуждаетесь в помощи. Вопросы, независимо от того, насколько 'глупыми' они кажутся, всегда будут отвечены максимально полезно и понятно, чтобы помочь разработчикам плагинов добиться успеха. Хороший код это хорошо для всех.

### Динамические обновления
EXILED как фреймворк поддерживает динамическую перезагрузку плагинов без необходимости перезагрузки сервера.
Например, если вы запустили сервер только с `Exiled.Events` как единственным плагином и хотите добавить новый, вам не нужно перезагружать сервер для выполнения этой задачи. Вы можете просто использовать команду Админ-панели, или консоли сервера `reload plugins`, чтобы перезагрузить все плагины EXILED, и загрузить новые, которые не были загружены ранее.

Это также означает, что вы можете *обновить* плагины без полной перезагрузки сервера. Однако существует несколько рекомендаций, которым должен следовать разработчик плагина, чтобы это работало:

***Для хостов***
- Если вы обновляете плагин, убедитесь, что его имя сборки (Не файла а сборки!) не совпадает с текущей версией, которую вы установили (если таковая имеется). Плагин должен быть собран разработчиком с учетом динамических обновлений, чтобы это работало, простое переименование файла не поможет.
- Если плагин поддерживает динамические обновления, убедитесь, что когда вы помещаете новую версию плагина в папку, вы также удаляете оттуда старую версию перед перезагрузкой EXILED, несоблюдение этого приведет к множеству проблем.
- Любые проблемы, возникающие при динамическом обновлении плагина, являются либо вашей ошибкой, либо ошибкой разработчика плагина. Хотя EXILED полностью поддерживает и поощряет динамические обновления, единственный вариант в котором они могут не работать - это когда вы или разработчик плагина сделали что-то неправильно. Убедитесь, что все было сделано обеими сторонами, прежде чем сообщать об ошибке разработчикам EXILED.

***Для разработчиков***

- Если вы хотите поддерживать динамические обновления, убедитесь что плагин отписывается от всех событий когда он отключен или перезагружен.
- Плагины, имеющие собственные патчи Harmony, должны сохранять экземпляр Harmony, и вызывать `UnPatchAll()`, когда плагин отключен или перезагружен.
- Любые корутины, запущенные плагином в `OnEnabled()`, также должны быть убиты при отключении или перезагрузке плагина.

Все это может быть сделано в методах `OnReloaded()` и `OnDisabled()` в классе плагина. Когда EXILED перезагружает плагин, он вызывает `OnDisabled()`, затем `OnReloaded()`, затем он загружает новые сборки, и только потом вызывает `OnEnabled()`.

Обратите внимание, что речь идет про *новые* сборки. Если вы замените сборку другой, но оставите тоже имя, она ***НЕ*** будет обновлена. Так происходит из-за GAC (Глобального кэша сборок). Если вы попытаетесь 'загрузить' сборку, которая уже находится в кеше, то загрузится кэшированная старая версия.
По этой причине, если ваш плагин поддерживает динамические обновления, вы должны собирать каждую версию с разным именем сборки (простое переименование файла не сработает). Кроме того, поскольку старая сборка не "уничтожается", когда она больше не нужна, если вы не отпишитесь от событий, не отмените патч своего экземпляра Harmony, не убьете корутины и т.д., то этот они будут продолжать работать вместе с кодом новой версии.
Будет излишним говорить что ничего хорошего из этого не выйдет.

Таким образом, плагины поддерживающие динамические обновления ***ОБЯЗАНЫ*** соблюдать эти правила, иначе они будут удалены с официального дискорд сервера, так как несут потенциальный риск для хостов.

Не каждый плагин обязан поддерживать динамические обновления. Если вы не собираетесь этого делать, то имеете на это полное право. Главное не изменяйте название сборки, когда создаете новую версию плагина, и убедитесь что владельцы серверов знают что для обновления вашего плагина сервер придется полностью перезапустить.

Перевод сделал BanalnyBanan
