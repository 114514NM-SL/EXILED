{
  "articles/contributing.html": {
    "href": "articles/contributing.html",
    "title": "Contributing | EXILED Docs",
    "keywords": "Contributing Contributing code Forking EXILED First, create a fork of our GitHub repository . Then, clone it to your computer like so: git clone https://github.com/your-username/EXILED.git Open a terminal in your forked EXILED folder and run git checkout dev . This will switch you to the dev branch, which all pull requests should be submitted to. Setting EXILED_REFERENCES If you haven't already, install the SCP: Secret Laboratory Dedicated Server through Steam or extract this zip file to an easily accessible folder. Windows users Open the Environment Variables menu by searching for Environment Variables in the Start Menu. Create a new environment variable titled EXILED_REFERENCES . The value should point to your_steamapps_directory/common/SCP Secret Laboratory Dedicated Server/SCPSL_Data/Managed , or to the folder where you extracted the zip file mentioned earlier. Linux users Add export EXILED_REFERENCES=\"PATH\" to your ~/.bashrc or similar file. PATH should point to your_steamapps_directory/common/SCP Secret Laboratory Dedicated Server/SCPSL_Data/Managed , or to the folder where you extracted the zip file mentioned earlier. You should now be able to open the EXILED directory in your favorite IDE. Once you are done, test your changes thoroughly, and then submit a pull request to the main EXILED repository. Make sure you are targeting the dev branch, not master ! Happy coding! Contributing docs Documentation is built using DocFX. Forking EXILED First, create a fork of our GitHub repository . Then, clone it to your computer like so: git clone https://github.com/your-username/EXILED.git Open a terminal in your forked EXILED folder and run git checkout dev . This will switch you to the dev branch, which all pull requests should be submitted to. DocFX installation If you have Chocolatey installed, installation is simple as choco install docfx Homebrew installation is just as simple: brew install docfx You can also get it via NuGet: nuget install docfx.console Writing and building docs All of our articles live in the docs/ directory in the root of the repository. To make a new article, simply create a new Markdown (.md) file in the docs/articles folder with a descriptive name. Then, add it to the toc.yml located in that same folder. For more information on toc.yml formatting, check the DocFX documentation. You can then write your article using Markdown. For more information on Markdown syntax, check out Markdown Guide. To build documentation, run docfx docfx.json and the completed documentation will be generated in _site/ . Do not push _site to GitHub, as GitHub Actions will generate updated documentation when it is pushed to master. You can then open _site/index.html in your favorite web browser to preview the results. Once you are done, submit a pull request to the main EXILED repository. Make sure you are targeting the dev branch, not master!"
  },
  "articles/faq.html": {
    "href": "articles/faq.html",
    "title": "Frequently Asked Questions | EXILED Docs",
    "keywords": "Frequently Asked Questions What is EXILED? EXILED - short for \"EXtended In-runtime Library for External Development\" is a plugin framework for SCP: Secret Laboratory compatible with MP2. It is not a direct replacement for SMOD, but it's purpose is to implement an event-based framework using Harmony patches, that plugin developers can utilize to develop plugins for SCP:SL servers. How do I install EXILED? See the Installing EXILED page for installation information. How do I install plugins? All plugins contain a DLL file (found in its latest release) that is used to load the plugin. Place the plugin in the appropriate plugin folder. Windows: %AppData%\\EXILED\\Configs(ServerPortHere)-configs.yml Linux: ~/.config/EXILED/Configs(ServerPortHere)-configs.yml Where is plugin configuration stored? Plugin configuration is stored in a separate folder than the base-game config files. Windows: %AppData%\\EXILED\\Plugins Linux: ~/.config/EXILED/Plugins Is there a plugin for upgrading items in hand, inside SCP-914? No, this is unnecessary because this is a base-game feature! Simply set the 914_mode config_gameplay config to DroppedAndHeld . What is Harmony? Harmony is a library that examines the code of a program as it is being run, allowing developers to tap into those functions, and run their own code, either adding onto, or completely replacing, the code the program would normally run. The reason EXILED uses harmony is to allow easier updating of the framework in conjunction with game updates. Under ideal circumstances, a new game update will not break EXILED itself, and the only thing needed to make EXILED work again, is a very simple copy/paste of a few lines of code into the new Assembly-CSharp file. By keeping all of our code outside of the Assembly, other developers can have full, unhindered access to the entirety of EXILED's source code, making collaboration easier. Additionally, it means that our code will be mostly unaffected by game updates. Unless the game drastically changes code in a very specific function EXILED uses for an event patch, a game update may not even require EXILED itself to also be updated."
  },
  "articles/install.html": {
    "href": "articles/install.html",
    "title": "Installing EXILED | EXILED Docs",
    "keywords": "Note This tutorial assumes that you are familiar with C# and with setting up a plugin in the EXILED framework. See the Plugin Structure tutorial if you are unfamiliar with setting up a plugin using EXILED. Installing EXILED Windows installation Download Exiled.Installer-Win.exe from here . Move it into your server directory and double click the .exe. If you would like to download pre-releases or specify other advanced options, you can reference all the flags here. Linux installation Download Exiled.Installer-Linux from here . Move it into your server directory and run it from the scp user using ./Exiled.Installer-Linux If you would like to download pre-releases or specify other advanced options, you can reference all the flags here. Plugin installation To install a plugin, simply place it in your plugins directory and restart your server. Your plugins directory should be located at %appdata%\\EXILED\\Plugins on Windows and ~/.config/EXILED/Plugins on Linux. Configs are autogenerated in the {port}-config.yml in the config directory, which can be found in %appdata%\\EXILED\\Configs on Windows and ~/.config/EXILED/Configs on Linux."
  },
  "articles/rich-text-reference.html": {
    "href": "articles/rich-text-reference.html",
    "title": "Rich Text Reference | EXILED Docs",
    "keywords": "Rich Text Reference This page contains a rich text reference for broadcasts and hints that can be used in EXILED plugins. Rendering Tags Applies bold or italics to the broadcast or hint. <b>Text</b> would produce Text . <i>Text</i> would produce Text . Color Applies a color to the broadcast or hint. <color=#FF0000>Text</color> would produce Text . <color=green>Text</color> would produce Text . See this table for a list of supported color names. Size Changes the size of the broadcast or hint. <size=30>Text</size> would increase the size of the text. <size=5>Text</size> would reduce the size of the text."
  },
  "articles/tutorials/events.html": {
    "href": "articles/tutorials/events.html",
    "title": "Events: What are they? | EXILED Docs",
    "keywords": "Note Note: This tutorial assumes that you are familiar with C# and with setting up a plugin in the EXILED framework. See the Plugin Structure tutorial if you are unfamiliar with setting up a plugin using EXILED. Events: What are they? Events play a key role in the EXILED framework and all of the plugins utilizing it. Almost every plugin created using the EXILED framework uses events in one way or another. So, what are they? An event is a simple way of being informed when something happens. Events range from the round ending, to a player throwing an item or opening a door, to even SCP-096 being enraged! Events allow you to attach code that executes when something occurs before, during, or at the conclusion of a round. For example, say that you have the following method. public void OnDead() { // Show hint to player. } With EXILED, it is possible to achieve the desired result: Showing a hint to a player who dies. Event structure The EXILED framework consists of two different types of events: Events that can be disallowed, and those that cannot. Events that can be disallowed can prevent certain events from happening; as an example, preventing a player from dying when they normally should. The ability to prevent certain events from happening is what gives EXILED its beauty. All events are part of a static class called a handler . All handlers can be found in the Exiled.Events namespace. Every handler is related to a specific feature in the game (eg. Exiled.Events.Scp096 contains SCP-096 related events). Almost all events have a corresponding event argument class. The event argument provides the data of an event, as well as the ability to prevent it from occurring. All event arguments can be found in the Exiled.Events.EventArgs namespace, and all event arguments inherit from System.EventArgs . Example: Enraging event The following is the structure of the Exiled.Events.EventArgs.EnragingEventArgs . public class EnragingEventArgs : System.EventArgs { // Note: Constructor omitted. public Scp096 Scp096 { get; } // The SCP-096 instance. public Player Player { get; } // The player controlling SCP-096. public bool IsAllowed { get; set; } // Whether or not SCP-096 can be enraged. } Notice the IsAllowed property of the event. This property, which defaults to true , can be set to false to prevent SCP-096 from being enraged. For most events that can be disallowed, IsAllowed is set to true by default, and plugins can set it to false to prevent the event from occurring. However, in some cases, IsAllowed defaults to false and plugins can set it to true to allow the event to occur. An example of this behavior is the InteractingDoor event. IsAllowed will default to false in this event if a player cannot open a door, however plugins may set it to true to allow the player to open it regardless. Connecting events Events can be connected and disconnected by using the += and -= operators. These can be used in the plugin's OnEnabled and OnDisabled methods, respectively. // Base plugin class // This example assumes a method called \"OnEnraging\" exists in this class. For best practice, you should create a new class to handle events. using Exiled.Events; public override void OnEnabled() { Scp096.Enraging += OnEnraging; // Scp096 is the event handler, while Enraging is the name of the event. The += operator connects this event to the provided method. } public override void OnDisabled() { Scp096.Enraging -= OnEnraging; // The -= operator disconnects this event from the provided method. } // Some other class using Exiled.Events.EventArgs; public void OnEnraging(EnragingEventArgs ev) // ev is the arguments for the event. Every event has a different argument class with different parameters, so make sure to check its documentation. { Log.Info(ev.Player.Nickname + \" has just been enraged!\"); }"
  },
  "articles/tutorials/mec.html": {
    "href": "articles/tutorials/mec.html",
    "title": "MEC (More Effective Coroutines) | EXILED Docs",
    "keywords": "Note Note: This tutorial assumes that you are familiar with C# and with setting up a plugin in the EXILED framework. See the Plugin Structure tutorial if you are unfamiliar with setting up a plugin using EXILED. MEC (More Effective Coroutines) If you are unfamiliar with MEC, this will be a very brief and simple primer to get you started. MEC Coroutines are basically timed methods, that support waiting periods of time before continuing execution, without interrupting/sleeping the main game thread. MEC coroutines are safe to use with Unity, unlike traditional threading, which will crash the server. MEC is useful for plugins which require a pre-defined timeout between execution. As an example, an automatic nuke plugin would want to pause for a certain amount of seconds before activating the warhead. A supply drop plugin would want to wait in certain intervals before executing a supply drop. Both of these are possible with MEC. Setup Unlike other API provided by SCP:SL, MEC requires a reference to the Assembly-CSharp-firstpass DLL file. After referencing this file, a using MEC; statement allows MEC to be used. Coroutine MEC offers tons of features for controlling threads. For this tutorial, we are going to look at two of them: coroutines, and delayed calls. A coroutine is a method that is executed by MEC and supports delays. These methods must return type IEnumerator<float> and must be called by Timing.RunCoroutine(Method()) . An example can be seen below, using an infinite loop with a 5 second delay. using MEC; using Exiled.API.Features; public void SomeMethod() { Timing.RunCoroutine(MyCoroutine()); } public IEnumerator<float> MyCoroutine() { for (;;) //repeat the loop infinitely { Log.Info(\"Hey, I'm a infinite loop!\"); //Call Log.Info to print a line to the game console/server logs. yield return Timing.WaitForSeconds(5f); //Tells the coroutine to wait 5 seconds before continuing. Since this is at the end of the loop, it effectively stalls the loop from repeating for 5 seconds. } } This example prints, \"Hey, I'm an infinite loop!\" every 5 seconds infinitely. Coroutines can have multiple yield return statements. Delayed Calls A simpler method of running an action after a delay is using Timing.CallDelayed(float, Action) , which executes code after a given number of seconds passes. This method does not require a coroutine to be created, hence why it's useful. An example can be seen below, logging a message 5 seconds after the method is called. using MEC; using Exiled.API.Features; public void SomeMethod() { Timing.CallDelayed(5f, () => // Execute the provided method 5 seconds late. { Log.Info(\"This log was printed 5 seconds late!\"); }) } It is strongly recommended that you do some googling, or ask around in the EXILED Discord server if you are unfamiliar with MEC and would like to learn more, get advice, or need help. Questions, no matter how 'stupid' they are, will always be answered as helpfully and clearly as possible for plugin developers to excel. Better code is better for everyone."
  },
  "articles/tutorials/plugin-structure.html": {
    "href": "articles/tutorials/plugin-structure.html",
    "title": "Plugin Structure | EXILED Docs",
    "keywords": "Note This tutorial assumes that you are familiar with C#. Plugin Structure In order to be loaded onto the framework, every plugin must follow a certain structure and inherit from certain members. If this is not achieved, the plugin will not execute. This tutorial will explain the proper setup for a plugin on the EXILED framework. Plugin Core Every plugin must have a .cs file that consists of the plugin class itself. This file (and the class itself) are typically simply named \"Plugin\"; however, any name is appropriate for the main plugin class. This example will use \"Plugin\" as the name of the class. After the main file is created, the Plugin class must be declared as a plugin, so that the EXILED framework loads it. This can be done by inheriting the Plugin<IConfig> class, provided in the Exiled.API.Features namespace. The following example shows how to properly inherit the class. However, notice the Config class inside of the angled brackets. This class must be created and must inherit from IConfig , which is part of the Exiled.API.Interfaces namespace. Upon the creation of the Config class, the interface will require you to add an IsEnabled property. namespace MyPluginNamespace { using Exiled.API.Features; public class Plugin : Plugin<Config> { // This plugin will now be recognized by the EXILED framework! } // It is strongly encouraged to create a separate file for your Config class. using Exiled.API.Interfaces; public class Config : IConfig { public bool IsEnabled { get; set; } } } By creating the Config class and including it in the angled brackets, the rest of the plugin's code, as well as the EXILED framework, will recognize that the class resembles configuration for server owners. For more information about setting up configuration, see the Configuration section below. OnEnabled and OnDisabled The plugin is now successfully loaded onto the framework. However, it doesn't actually do anything; no functionality has been assigned. The Plugin<IConfig> class provides two overridable methods in order to give the plugin functionality: OnEnabled and OnDisabled . These two methods do exactly as they sound: Execute when the plugin is enabled/loaded, and when it is disabled. The following example shows how to utilize these methods to send a message to the console. namespace MyPluginNamespace { using Exiled.API.Features; public class Plugin : Plugin<Config> { public override void OnEnabled() { Log.Info(\"My plugin has been enabled!\"); } public override void OnDisabled() { Log.Info(\"My plugin has been disabled!\"); } } // Config.cs file using Exiled.API.Interfaces; public class Config : IConfig { public bool IsEnabled { get; set; } } } All of the code for the plugin must be enabled in the OnEnabled method, and must be disabled on the OnDisabled method. It is important that these two methods execute as expected, because server hosts can enable and disable plugins as much as they'd like, and the plugin must be able to respond to these changes appropriately. Plugin Data In order for a plugin to be submitted for public use, the plugin must override three properties: Name , Author , and Version . The first two are strings, whereas the last one is a Version class ( using System; is required). The following example shows how to properly override this data. namespace MyPluginNamespace { using System; using Exiled.API.Features; public class Plugin : Plugin<Config> { public override string Name => \"My Awesome Plugin\"; public override string Author => \"MyName\"; public override Version Version => new Version(1, 0, 0); } // ... } Configuration This section is related to creating and reading the value of configuration. Creating Configs A lot of plugins provide configuration to allow the server hosts to change various features of the plugin. Luckily, creating configuration is very simple. To start, take a look at your Config.cs file. namespace MyPluginNamespace { using Exiled.API.Interfaces; public class Config : IConfig { public bool IsEnabled { get; set; } } } There is currently one config, called IsEnabled . As stated above, this config is required and cannot be removed. However, more config can be added. The YAML serialization allows almost any type to be added and still work, including bools, ints, arrays of anything, enums, and even whole classes! In the following example, a config file with three configs is created. namespace MyPluginNamespace { using Exiled.API.Interfaces; public class Config : IConfig { public bool IsEnabled { get; set; } public bool MyBoolConfig { get; set; } public string MyStringConfig { get; set; } public int MyIntConfig { get; set; } = 5; // Set to 5 by default. } } To server hosts, the functionality of these configs might be confusing at first. So, the System.ComponentModel.DescriptionAttribute can be used to provide a description for each config! namespace MyPluginNamespace { using System.ComponentModel; using Exiled.API.Interfaces; public class Config : IConfig { [Description(\"Whether or not the plugin is enabled.\")] public bool IsEnabled { get; set; } [Description(\"Config that must be true or false!\")] public bool MyBoolConfig { get; set; } [Description(\"Config that must be a string!\")] public string MyStringConfig { get; set; } [Description(\"Config that must be a number! Defaults to 5.\")] public int MyIntConfig { get; set; } = 5; } } Reading Configs Note You do not need to read the value of the IsEnabled config; EXILED will automatically prevent your plugin from executing if its IsEnabled config is set to false. Reading configuration is more simple than creating it. The base Plugin<IConfig> class provides a property, called Config , which can be used to access these values. In the following example, our config from the previous class is displayed when the plugin starts. namespace MyPluginNamespace { using Exiled.API.Features; public class Plugin : Plugin<Config> { public override void OnEnabled() { Log.Info(\"Boolean config: \" + Config.MyBoolConfig); Log.Info(\"String config: \" + Config.MyStringConfig); Log.Info(\"Int config: \" + Config.MyIntConfig); } } // Config.cs file using System.ComponentModel; using Exiled.API.Interfaces; public class Config : IConfig { [Description(\"Whether or not the plugin is enabled.\")] public bool IsEnabled { get; set; } [Description(\"Config that must be true or false!\")] public bool MyBoolConfig { get; set; } [Description(\"Config that must be a string!\")] public string MyStringConfig { get; set; } [Description(\"Config that must be a number! Defaults to 5.\")] public int MyIntConfig { get; set; } = 5; } }"
  },
  "index.html": {
    "href": "index.html",
    "title": "EXILED (EXtended In-runtime Library for External Development) | EXILED Docs",
    "keywords": "EXILED (EXtended In-runtime Library for External Development) EXILED is a low-level plugin framework for SCP: Secret Laboratory servers. Our documentation is still a work in progress, help us out by following the instructions here!"
  }
}